# 基礎
## 世界の修正
さてどうやってØMQを説明しましょうか。
私達の中には、素晴らしい事柄を並べて説明を始める人もいます。
それはソケットのステロイド化合物だ。それはメールボックスのルーティングの様だ。それは速い!
その他にはzap-pow-kaboomパラダイムシフトの悟りを開き、全てが明解になる瞬間を共有しようとする人もいます。
物事は単純になります。複雑さは消え、心を開くのです…

もっと他の説明を試してみましょう。それはもっと短く単純ですが馴染みやすいです。
個人的に何故私達がØMQを作ったかという話を覚えておいて欲しいです。
何故かというと、ほとんどの読者も同じ問題を抱えているはずだからです。

プログラミングは芸術としてドレスアップされた理学です。私達のほとんどはこれまで教わったことがないために、ソフトウェアの物理学を理解していません。
ソフトウェアの物理学とはアルゴリズムやデータ構造、言語、抽象化などではありません。
それらは唯の道具であり、作って使い捨てるものです。
本当のソフトウェアの物理学とは人間の物理学です。
具体的には、複雑性による私達の限界や巨大な問題を解決したいという欲求です。
人々が簡単に理解して利用できるブロックを作り、協力して大きな問題を解決する事こそがプログラミングの理学です。

私達は接続された世界に住んでいて、現代のソフトウェアはこの世界を往来しなければなりません。
ですから、ブロックは明日には巨大なシステムに接続され、大量に平行化されるかもしれないのです。
コードは強く物静かであるだけでは不十分です。
コードはコードと会話し、社交的なおしゃべりでなくてはなりません。
コードは人間の脳にある何兆もの独立したニューロンの様にお互いにメッセージを発し、中央制御が必要なく、単一障害点の存在しない超並列ネットワークを構成して動作しなければなりません。そうしてやっと、困難な問題を解決できるようになります。
この様なコードの未来が人間の脳と似ていることは偶然ではありません。
ネットワークのエンドポイントは幾つかのレベルで人間の動と同じだからです。

もしあなたがスレッドやプロトコル、ネットワークを駆使してこれを自分で実装しようとした場合、到底不可能であることに気がつくでしょう。それは夢物語です。
コネクション毎に複数のソケットを扱うプログラムは現実的には地味に厄介です。
想像を絶するコストが掛かります。
数十億ドル規模のビジネスでコンピューターを接続するソフトウェアやサービスを行うことは非常に困難です。

私達は自分たちの扱える能力に見合った世界で生活しています。
1980年代にソフトウェア業界の重大局面がありました。
フレデリック・ブルックスのような有名ソフトウェア・エンジニアが生産性、信頼性、単純性を大幅に改善する[「銀の弾など存在しない」](http://en.wikipedia.org/wiki/No_Silver_Bullet)と信じたことです。

ブルックスはオープンソースソフトウェアが効果的に知識を共有するする事を可能にして重大局面を解決することを見落としていました。
そして現在、ソフトウェア業界は別の重大局面に直面していますがこれについて話したがる人はあまり居ません。
最も巨大で裕福な企業のみが、接続するアプリケーションを開発する余裕があります。
それはプロプライエタリなクラウドです。
我々のデータと知識はパーソナルコンピューターの中からクラウドの中に消えてしまい、我々自身もアクセス出来なくなっています。
ソーシャルネットワークを自分自身で持っている人はいますか?
これではまるでメインフレーム-パーソナルコンピューター革命を逆行しているようです。

政治哲学的な話はこの辺にしておいて[他の本](http://swsi.info/)に譲る事にしますが、
重要なのは、インターネットは潜在的に大量のコードが接続しあうにも関わらず、現実に私達には手の届かない所にあるという事です。
そしてこれは健康、教育、経済、運輸などにおいて非常に興味深い問題を引き起こしますが、コードを接続する方法が無いので未だ解決出来ていません。
したがって、これらの問題を解決するために脳を接続出来る相手と一緒に仕事するしかありません。

コードを接続する問題に関して多くの試みが行われてきました。
何千ものIETFの仕様があります。これらは問題を解決するパズルの一部です。
HTTPは恐らくアプリケーション開発者にとって単純明解な解決方法の一つでしょう。しかしそれは楽観的な開発者や設計者による、巨大なサーバーと貧弱なクライアントを前提とした考えであり、問題を悪化させるでしょう。

そして現在でも人々はUDPやTCP、プロプライエタリなプロトコル、HTTP、Webソケットを使用してアプリケーションを接続しています。
それは痛みを伴うほど遅く、拡張が難しく、本質的に中央集中型です。
分散P2Pはほとんど娯楽のためであり、ビジネスで使うには難しいでしょう。
SkypeやBittorrentとデータを交換するアプリケーションがどれほどあるでしょうか?

プログラミングの理学の話に立ち帰ると、世界を修正するために我々は2つの事を行う必要があります。
一つ目は一般的な問題である「何処でもコードとコードを接続出来るようにする方法」を解決すること。
二つ目は人々が簡単に理解して利用できる単純なブロックでそれを包み込む事です。

それは馬鹿馬鹿しいほど単純に聞こえるし、多分きっとそうなんでしょう。
しかしこれはとても肝心な事です。

## 前提条件
あなたが最新のØMQ バージョン 3.2を利用している事を想定しています。
また、あなたがLinuxマシンまたは類似の何かを利用していることを想定します。
サンプルコードの既定の言語はC言語ですので、あなたが多かれ少なかれC言語が読めることを想定しています。
私が`PUSH`や`SUBSCRIBE`といった定数を書いた時、実際には`ZMQ_PUSH` や `ZMQ_SUBSCRIBE` という様にプログラミング言語で使われる記述に読み替えてくれる事を想定しています。

## サンプルコードの取得
サンプルコードはGitHubの公開レポジトリから取得できます。
全てのサンプルコードを取得する最も簡単な方法はレポジトリをcloneすることです。

    git clone --depth=1 git://github.com/imatix/zguide.git

続いて、examplesサブディレクトリを参照します。
プログラミング言語毎のディレクトリ見つけるでしょう。
もしあなたが利用している言語が無い場合は移植して送ってもらえると助かります。
この様にして多くの人々の協力でこのテキストは便利になりました。
全てのサンプルコードはMIT/X11ライセンスで公開されています。

## 尋ねよ、さらば受け取らん
さあ、コードから始めましょう。
まずはHello Worldのサンプルコードから始めます。
私達はこれからクライアントとサーバーを作ります。
クライアントが "Hello" をサーバーに送信したら、サーバーは "World" を応答します。
ここでは、サーバーはØMQソケットをTCPポート5555番で開き、リクエストを受け取ったら "World" を応答するコードをC言語で実装しています:

~~~ {caption="hwserver.c: Hello Worldサーバー"}
// Hello Worldサーバー

#include <zmq.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

int main (void)
{
    // クライアントと通信を行うソケット
    void *context = zmq_ctx_new ();
    void *responder = zmq_socket (context, ZMQ_REP);
    int rc = zmq_bind (responder, "tcp://*:5555");
    assert (rc == 0);

    while (1) {
        char buffer [10];
        zmq_recv (responder, buffer, 10, 0);
        printf ("Received Hello\n");
        sleep (1); // Do some 'work'
        zmq_send (responder, "World", 5, 0);
    }
    return 0;
}
~~~

![リクエストと応答](images/fig2.eps)

REQ-REPソケットペアはロックステップ方式です。
クライアントはループ内で`zmq_send()`してから`zmq_recv()`を発行します。
それ以外のケース、例えば2回メッセージを送信した場合などでは`zmq_send()`や`zmq_recv()`で-1が返ります。
同様にサーバー側は`zmq_recv()`してから`zmq_send()`を発行する必要があります。

ØMQは主要な部分にC言語を利用しているので、サンプルコードでもC言語を使います。
ここではC++のコードを見て比べてみましょう。

~~~ {caption="hwserver.cpp: Hello Worldサーバー"}
//
// Hello Worldサーバー(C++版)
// REPソケットをtcp://*:5555 でバインドします。
// クライアントが"Hello"を送信してきた時、"World"と応答します。
//
#include <zmq.hpp>
#include <string>
#include <iostream>
#ifndef _WIN32
#include <unistd.h>
#else
#include <windows.h>
#endif

int main () {
    // コンテキストとソケットの準備
    zmq::context_t context (1);
    zmq::socket_t socket (context, ZMQ_REP);
    socket.bind ("tcp://*:5555");

    while (true) {
        zmq::message_t request;

        // クライアントからのリクエストを待機
        socket.recv (&request);
        std::cout << "Received Hello" << std::endl;

        // 何らかの処理
#ifndef _WIN32
    sleep(1);
#else
    Sleep (1);
#endif

        // クライアントに応答
        zmq::message_t reply (5);
        memcpy ((void *) reply.data (), "World", 5);
        socket.send (reply);
    }
    return 0;
}
~~~

ØMQのAPIはC言語とC++で同様だという事が解ると思います。
PHPとJavaの例も見てみましょう。

~~~ {caption="hwserver.php: Hello Worldサーバー"}
<?php
/*
* Hello Worldサーバー(PHP)
* REPソケットをtcp://*:5555 でバインドします。
* クライアントが"Hello"を送信してきた時、"World"と応答します。
* @author Ian Barber <ian(dot)barber(at)gmail(dot)com>
*/

$context = new ZMQContext(1);

// クライアントとの通信ソケット
$responder = new ZMQSocket($context, ZMQ::SOCKET_REP);
$responder->bind("tcp://*:5555");

while (true) {
    // クライアントカアラのリクエストを待機
    $request = $responder->recv();
    printf ("Received request: [%s]\n", $request);

    // 何らかの処理
    sleep (1);

    // クライアントに応答
    $responder->send("World");
}
~~~

~~~ {caption="hwserver.java: Hello Worldサーバー"}
//
// Hello Worldサーバー(Java)
// REPソケットをtcp://*:5555 でバインドします。
// クライアントが"Hello"を送信してきた時、"World"と応答します。
//

import org.zeromq.ZMQ;

public class hwserver{

    public static void main (String[] args) throws Exception{
        ZMQ.Context context = ZMQ.context(1);
        // クライアントとの通信ソケット
        ZMQ.Socket socket = context.socket(ZMQ.REP);
        socket.bind ("tcp://*:5555");

        while (!Thread.currentThread ().isInterrupted ()) {
            byte[] reply = socket.recv(0);
            System.out.println("Received Hello");
            Thread.sleep(1000); // 何らかの処理
            String request = "World" ;
            socket.send(request.getBytes (), 0);
        }
        socket.close();
        context.term();
    }
}
~~~

以下はクライアントのコードです。

~~~ {caption="hwclient: Hello Worldクライアント(C言語)"}
// Hello Worldクライアント
#include <zmq.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

int main (void)
{
    printf ("Connecting to hello world server…\n");
    void *context = zmq_ctx_new ();
    void *requester = zmq_socket (context, ZMQ_REQ);
    zmq_connect (requester, "tcp://localhost:5555");

    int request_nbr;
    for (request_nbr = 0; request_nbr != 10; request_nbr++) {
        char buffer [10];
        printf ("Sending Hello %d…\n", request_nbr);
        zmq_send (requester, "Hello", 5, 0);
        zmq_recv (requester, buffer, 10, 0);
        printf ("Received World %d\n", request_nbr);
    }
    zmq_close (requester);
    zmq_ctx_destroy (context);
    return 0;
}
~~~

さて、この例は現実的にあまりにも単純に見えますが、これまで学んできたようにØMQソケットはとんでもない力を秘めています。
あなたは同時に数千のクライアントでこのサーバーに接続することができ、問題なく迅速に動作し続けるでしょう。
戯れに、サーバーを立ち上げてクライアントを実行してどんな風に動作するか試してみてください。
そしてこの意味を少し考えてみて下さい。

これら2つのプログラムが実際に何をしているか簡潔に説明しましょう。
これらはまずØMQコンテキストとソケットを作成します。言葉の意味についてはまだ心配しないで下さい。それらは後で説明します。サーバーはREP(応答)ソケットをポート5555番でbindします。サーバーはループの中でリクエストを待ち、リクエスト毎に応答します。
クライアントは、リクエストを送信し、サーバーからの応答を受け取ります。

サーバーをCtrl-Cで終了して再起動した場合、クライアントは適切に復旧しません。
プロセスの異常終了からの復旧は簡単なことではありません。
信頼性の高いリクエスト-応答フローを構成することは十分複雑なので、これについては4章の「Reliable Request-Reply Patterns」で取り上げます。

我々プログラマにとって、どんなに短く素敵なコードでも裏側ではたくさんの事が起こっています。
そして、どれだけ負荷を掛けてもクラッシュしません。
これをリクエスト-応答パターンと呼びます。
恐らく、ØMQの最も単純な利用方法です。
これはRPCとか、古典的なクライアント・サーバーモデルに対応します。

## 文字列に関する補足
ØMQはデータについてサイズ以外の事は何も知りません。
これは、プログラマがアプリケーション側で安全に読み戻せるようにする責任があるという事を意味します。
オブジェクトや複雑なデータ構造を利用する事はProtocol Buffersの様なライブラリの役目です。
文字列でさえ気を配ってやる必要があります。

C言語や幾つかの言語では、文字列はNULL文字で終端してます。
"HELLO"という様な文字列を送信する際、以下の様にNULL文字付きで送信出来ます。

    zmq_send (requester, "Hello", 6, 0);

しかしながらその他の言語ではNULL文字を含まない場合があります。
例えばPythonでは、以下のようにして文字列を送信します。

    socket.send ("Hello")

この時、文字列の長さと文字列の内容がネットワーク上を流れます。

![ØMQ文字列](images/fig3.eps)

そしてもしC言語のプログラムでこれを読むと、あなたは偶然文字列の様なものを受け取るでしょうが、これは正しい文字列ではありません。
クライアントとサーバーで文字列フォーマットに関する同意がない場合、おかしな結果が得られるかもしれません。

C言語で文字列を受信する際、文字列が安全にNULL終端していると期待してはいけません。
文字列を読み込む際には、新たに大きめの新しくバッファを確保し、コピーして適切にNULL文字で終端させてやる必要があります。

それでは、*NULL終端していないØMQ文字列が送られてきた場合*のルールを確立しましょう。
最も単純なケースでは、先の図の様にØMQ文字列の長さと内容はØMQメッセージフレームにぴったり一致します。

以下の例は、C言語で受け取ったØMQ文字列を適切な文字列としてアプリケーションに受け渡す為に何を行う必要があるのかを示しています。

~~~
// ソケットから0MQ文字列を受信してC文字列に変換する
// 255文字より長い文字列は打ち切る
static char *
s_recv (void *socket) {
    char buffer [256];
    int size = zmq_recv (socket, buffer, 255, 0);
    if (size == -1)
        return NULL;
    if (size > 255)
        size = 255;
    buffer [size] = 0;
    return strdup (buffer);
}
~~~

モノ作り精神で作成したこの便利なヘルパー関数は有効に再利用することが出来ます。
同様に、正しいØMQフォーマット文字列を送信するs_send関数も書いてみましょう。
そして再利用できるヘッダーファイルをパッケージングします。

その成果がzhelpers.hであり、これによって短く簡潔にØMQアプリケーションを書くことが出来ます。
このソースコードは相当長いですが、興味があるC開発者の方は余裕がある時に読んでみて下さい。

## バージョン報告
ØMQには幾つかのバージョンがあり、頻繁にバージョンアップします。
もし問題に遭遇したとしても最新のバージョンで修正されていることが多いでしょう。
ですのでØMQのバージョンを正確に調べる方法を知っておくと役に立つでしょう。

以下はそれを行う小さなプログラムです:

~~~ {caption="version: ØMQのバージョン報告(C言語)"}
// 0MQのバージョン報告

#include <zmq.h>

int main (void)
{
    int major, minor, patch;
    zmq_version (&major, &minor, &patch);
    printf ("Current 0MQ version is %d.%d.%d\n", major, minor, patch);
    return 0;
}
~~~

## メッセージ配信
第二の典型的なパターンは、サーバーから複数のクライアントに更新をプッシュする一方方向のデータ配信です。
それでは、郵便番号と気温、湿度からなる気象情報をプッシュ配信する例を見てみましょう。
ここで利用する気象情報はランダムに生成した値を利用することにします。

以下がサーバーのサンプルコードです。このアプリケーションはTCP 5556番ポートを利用します。

~~~ {caption="wuserver: 気象情報更新サーバー(C言語)"}
// 気象情報更新サーバー
// PUBソケットを tcp://*:5556 でバインドし、
// ランダムな気象情報を配信する

#include "zhelpers.h"

int main (void)
{
    // コンテキストとパブリッシャーの準備
    void *context = zmq_ctx_new ();
    void *publisher = zmq_socket (context, ZMQ_PUB);
    int rc = zmq_bind (publisher, "tcp://*:5556");
    assert (rc == 0);
    rc = zmq_bind (publisher, "ipc://weather.ipc");
    assert (rc == 0);

    // 乱数生成器の初期化
    srandom ((unsigned) time (NULL));
    while (1) {
        // Get values that will fool the boss
        int zipcode, temperature, relhumidity;
        zipcode = randof (100000);
        temperature = randof (215) - 80;
        relhumidity = randof (50) + 10;

        // 全サブスクライバーにメッセージを送信
        char update [20];
        sprintf (update, "%05d %d %d", zipcode, temperature, relhumidity);
        s_send (publisher, update);
    }
    zmq_close (publisher);
    zmq_ctx_destroy (context);
    return 0;
}
~~~

終りの無い放送の様に、このストリームの配信に始まりと終わりはありません。

以下のクライアントアプリケーションはストリームの配信を聞き取り、特定の郵便番号に関するデータを収集します。デフォルトではニューヨークを指定しています。なぜならそこは冒険を始めるには絶好の場所だからです。

~~~ {caption="wuclient: 気象情報更新クライアント(C言語)"}
// 気象情報更新クライアント
// SUBソケットで tcp://localhost:5556 に接続
// 気象情報を収集し、対象郵便番号の平均値を求める

#include "zhelpers.h"

int main (int argc, char *argv [])
{
    // サーバーと通信するソケット
    printf ("Collecting updates from weather server…\n");
    void *context = zmq_ctx_new ();
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    int rc = zmq_connect (subscriber, "tcp://localhost:5556");
    assert (rc == 0);

    // Subscribe to zipcode, default is NYC, 10001
    char *filter = (argc > 1)? argv [1]: "10001 ";
    rc = zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,
                         filter, strlen (filter));
    assert (rc == 0);

    // Process 100 updates
    int update_nbr;
    long total_temp = 0;
    for (update_nbr = 0; update_nbr < 100; update_nbr++) {
        char *string = s_recv (subscriber);

        int zipcode, temperature, relhumidity;
        sscanf (string, "%d %d %d",
                &zipcode, &temperature, &relhumidity);
        total_temp += temperature;
        free (string);
    }
    printf ("Average temperature for zipcode '%s' was %dF\n",
            filter, (int) (total_temp / update_nbr));

    zmq_close (subscriber);
    zmq_ctx_destroy (context);
    return 0;
}
~~~

![パブリッシュ・サブスクライブ](images/fig4.eps)

SUBソケットを利用する際、このコードの様に`zmq_setsockopt()`で`SUBSCRIBE`を*設定しなければならない*ことに注意して下さい。もし設定しなかった場合メッセージを受信できません。これはよくある初歩的なミスです。サブスクライバーは複数のサブスクリプションを設定できます。その際サブスクリプションにマッチした更新のみ受信します。
サブスクライバーは特定のサブスクリプションをキャンセルすることも出来ます。
サブスクリプションは必ずしも印字可能な文字とは限りません。
これがどの様に動作するかは`zmq_setsockopt()`を読んで下さい。

PUB-SUBソケットのペアは非同期で動作し、クライアントは通常ループ内で`zmq_recv()`を呼び出します。
SUBソケットでメッセージを送信しようとするとエラーが発生します。
同様に、PUBソケットで`zmq_recv()`を呼んではいけません。

理論上は、どちらがbindしてどちらが接続しても問題ないはずです。
しかし今の所ドキュメント化されていないので出来ればPUBでbindしてSUBで接続して下さい。

PUB-SUBソケットについて知るべき重要なことがもうひとつあります。
それは、サブスクライバーがいつメッセージを受信し始めたかどうかを正確に知ることは出来ないという事です。
サブスクライバーを起動し、しばらく経ってパブリッシャーを起動した場合でも*必ず最初のメッセージを取りこぼします*。
これは、サブスクライバがパブリッシャーに接続している間(一瞬だがゼロでは無い時間)に、パブリッシャーがメッセージを配信している可能性が在るからです。

多くの人がこの「参加遅延症状」に遭遇するので私達はこれについての説明を頻繁に行います。
ØMQが非同期I/Oであることを思い出して下さい。
２ノードでこれを行う際、バックグラウンドでは以下の事を以下の順序で行います。

 * サブスクライバはエンドポイントに接続し、メッセージを受信して数える。
 * パブリッシャーはエンドポイントをbindし、即座に1000メッセージを送信する。

フィルタが正しく設定されているか確認し、メッセージは無視されます。
従ってサブスクライバーはまだ何も受信していないことになります。

TCPコネクションの作成およびハンドシェイクはネットワークやピア間のホップ数に応じて数ミリ秒の遅延を発生させます。
ØMQはこの間に多くのメッセージを送信できます。
便宜上、コネクションの確立に5ミリ秒かかり、1秒間に1Mメッセージを処理できると仮定すると、パブリッシャーはサブスクライバが接続しているわずか5ミリ秒の間に、5Kのメッセージを送信出来ることになります。

「2章 ソケットとパターン」ではパブリッシャーとサブスクライバを同期してサブスクライバの準備が整うまでパブリッシャーがデータを配信しないようにする方法を説明します。
単純にsleepを入れて遅延させるという愚かな方法もありますが、実用のアプリケーションでこれをやると極めて不安定な上に遅いのでやらないで下さい。
正しくこれをやる方法と、sleepを行うと何が起こるかは「2章 ソケットとパターン」まで待って下さい。

同期を行わない場合、サーバーは無限にデータを配信することを前提とし、サブスクライバは開始時に始まりと終わりを扱いません。
これは天気クライアントの例で見てきた通りです。

まとめると、クライアントは指定した郵便番号の更新を100個収集します。
郵便番号がランダムに分布している場合には、約1千万の更新が送られてくることになります。
クライアントを開始した後に、サーバを起動してもクライアントは問題なく動作します。
サーバーを好きなタイミングで再起動しても、クライアントは動作し続けます。
クライアントが100の更新を収集すると、平均値を計算し、表示して終了します。

パブリッシュ・サブスクライブ(pub-sub)パターンの要点は以下の通りです。

 * サブスクライバーは一つ以上のパブリッシャーに接続することが出来ます。一つのパブリッシャーが大量のメッセージを流して専有してしまわないように、到着したデータは制御されています。これを「平衡キューイング」と呼びます。

 * パブリッシャーに接続しているサブスクライバーが居ない時、全てのメッセージは単純に破棄されます。

 * TCPを利用していて、サブスクライバが遅い場合、メッセージがパブリッシャーのキューに入れられます。「high-water mark」を利用してどの様にしてパブリッシャーを保護するかは後で説明します。

 * ØMQ v3.x以降、ステートフルプロトコル(tcp: もしくは ipc:)を利用している場合にパブリッシャー側でフィルタリング出来るようになりました。epgm:// プロトコルを利用するばあいは、サブスクライバ側でフィルタリングします。ØMQ v2.xでは全てのフィルタリングはサブスクライバ側で行います。

これは、2011年に買ったIntel i5の普通のノートPCで1千万のメッセージを受信してフィルタリングするのに掛かった時間です。

~~~
$ time wuclient
Collecting updates from weather server...
Average temperature for zipcode '10001 ' was 28F

real    0m4.470s
user    0m0.000s
sys     0m0.008s
~~~

## 分割統治法

![並行パイプライン](images/fig5.eps)

最後の例は小さなスパコンで計算してみましょう。そして沢山のコードばかりを見てきて疲れたでしょうからコーヒーでも飲んで休憩してください。
スパコンのアプリケーションは典型的な並行処理モデルです。

 * ベンチレーターは並行に処理できるタスクを生成します。
 * ワーカー群はタスクを処理します。
 * シンクはワーカーの処理結果を収集します。

実際にはワーカーはGPUなどを搭載した高速マシンで実行されます。
ベンチレーターは100のタスクを生成しワーカーに送信します。
ワーカーは受け取った数×ミリ秒のsleepを行います。

~~~ {caption="taskvent: 並行タスクベンチレーター(C言語)"}
// タスクベンチレーター
// PUSHソケット tcp://localhost:5557 をバインド
// ソケットを経由して、ワーカーに処理タスクを送信する

#include "zhelpers.h"

int main (void)
{
    void *context = zmq_ctx_new ();

    // Socket to send messages on
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_bind (sender, "tcp://*:5557");

    // Socket to send start of batch message on
    void *sink = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sink, "tcp://localhost:5558");

    printf ("Press Enter when the workers are ready: ");
    getchar ();
    printf ("Sending tasks to workers…\n");

    // The first message is "0" and signals start of batch
    s_send (sink, "0");

    // Initialize random number generator
    srandom ((unsigned) time (NULL));

    // Send 100 tasks
    int task_nbr;
    int total_msec = 0; // Total expected cost in msecs
    for (task_nbr = 0; task_nbr < 100; task_nbr++) {
        int workload;
        // Random workload from 1 to 100msecs
        workload = randof (100) + 1;
        total_msec += workload;
        char string [10];
        sprintf (string, "%d", workload);
        s_send (sender, string);
    }
    printf ("Total expected cost: %d msec\n", total_msec);

    zmq_close (sink);
    zmq_close (sender);
    zmq_ctx_destroy (context);
    return 0;
}
~~~

以下はワーカーアプリケーションです。
メッセージを受信した数の秒数sleepし、完了を通知します。

~~~ {caption="taskwork: 並行タスクワーカー(C言語)"}
// タスクワーカー
// Connects PULL socket to tcp://localhost:5557
// Collects workloads from ventilator via that socket
// Connects PUSH socket to tcp://localhost:5558
// Sends results to sink via that socket

#include "zhelpers.h"

int main (void)
{
    // Socket to receive messages on
    void *context = zmq_ctx_new ();
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, "tcp://localhost:5557");

    // Socket to send messages to
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sender, "tcp://localhost:5558");

    // Process tasks forever
    while (1) {
        char *string = s_recv (receiver);
        printf ("%s.", string); // Show progress
        fflush (stdout);
        s_sleep (atoi (string)); // Do the work
        free (string);
        s_send (sender, ""); // Send results to sink
    }
    zmq_close (receiver);
    zmq_close (sender);
    zmq_ctx_destroy (context);
    return 0;
}
~~~

以下はシンクアプリケーションです。
100のタスクを収集し、処理にどれくらいの時間が掛かったかを求めます。
これにより、本当に並行処理が行われたどうかを確認できます。

~~~ {caption="tasksink: Parallel task sink in C"}
// Task sink
// Binds PULL socket to tcp://localhost:5558
// Collects results from workers via that socket

#include "zhelpers.h"

int main (void)
{
    // Prepare our context and socket
    void *context = zmq_ctx_new ();
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_bind (receiver, "tcp://*:5558");

    // Wait for start of batch
    char *string = s_recv (receiver);
    free (string);

    // Start our clock now
    int64_t start_time = s_clock ();

    // Process 100 confirmations
    int task_nbr;
    for (task_nbr = 0; task_nbr < 100; task_nbr++) {
    char *string = s_recv (receiver);
        free (string);
        if ((task_nbr / 10) * 10 == task_nbr)
            printf (":");
        else
            printf (".");
        fflush (stdout);
    }
    // Calculate and report duration of batch
    printf ("Total elapsed time: %d msec\n",
    (int) (s_clock () - start_time));

    zmq_close (receiver);
    zmq_ctx_destroy (context);
    return 0;
}
~~~

平均的な実行時間は大体5秒程度です。
ワーカーを1, 2, 4個と増やした時の結果は以下の通りです。

 * 1ワーカー: total elapsed time: 5034 msecs.
 * 2ワーカー: total elapsed time: 2421 msecs.
 * 4ワーカー: total elapsed time: 1018 msecs.

それでは、もっと詳しくコードの性質を見ていきましょう。

 * ワーカーは上流のベンチレーターと下流のシンクに接続します。これは自由にワーカーを追加できる機能を持っているという事です。もしもワーカーがbindを行ったとすると、ワーカーを追加する度にベンチレーターとシンクの動作を変更しなければなりません。ベンチレーターとシンクがアーキテクチャの固定部品であり、ワーカーは動的な部品であると言えます。

 * 全てのワーカーが起動するまで、処理の開始を同期させる必要があります。これはØMQのよくある落とし穴であり、簡単な解決方法はありません。どうしてもzmq_connectメソッドはある程度の時間がかかってしまいます。複数のワーカーがベンチレーターに接続する際、最初のワーカーが正常に接続してメッセージを受信しても、他のワーカーはまだ接続中の状態になります。何らかの方法で、処理の開始を同期しなければシステムは並行に動作しません。試しにgetcharによる一時停止を削除して、何が起こるか確認してみましょう。

 * ベンチレーターのPUSHソケットはタスクを均等にワーカーに分散します(処理が開始されるまでに全てのワーカーは接続済みであると仮定します)。これはロードバランシングと呼ばれ、後ほど改めて詳細を見ていきます。

 * シンクのPULLソケットはワーカーからの処理結果を均等に収集します。これは*平衡キューイング*と呼びます。

![平衡キューイング](images/fig6.eps)

この様なパターンで「参加遅延病」が発症した場合、PUSHソケットが適切にロードバランスしなくなる現象を引き起こします。
PUSHとPULLを利用している場合、あるワーカーが他のワーカーより多くのメッセージを受け取ることになります。なぜならばあるPULLソケットは早く接続していて、その他のソケットが接続している間に多くのメッセージを受け取るからです。もしあなたが正確なロードバランシングを行いたいと考えている場合、「第3章 - Advanced Request-Reply Patterns」を参照して下さい。

## ØMQプログラミング
幾つかのサンプルコードを見てきました。あなたはØMQでなにかアプリケーションを作りたくて仕方が無いのでしょう。
それを始める前に、大きく深呼吸をして落ち着き、ストレスと混乱を避けるために幾つかの基本的なアドバイスに耳を傾けて下さい。

 * 一歩ずつØMQを学んで下さい。これはとてもシンプルなAPIですが、あらゆる可能性が潜んでいます。起こりうる可能性を一つずつ学んでいってください。

 * 素敵なコードを書いて下さい。醜いコードは問題を隠蔽し、他の人があなたを助けることを困難にします。変数名に無意味な名前を利用すると誰もあなたのコードを読めなくなるでしょう。変数の意味を伝えるのに適切な現実の世界の言葉を使って下さい。一貫したインデントと綺麗なレイアウトを使って下さい。素敵なコードを書くとあなたの世界はより快適になります。

 * あなたが作ったものをテストして下さい。プログラムが動作しない時あなたのコードに責任があることを知るべきです。ØMQを初めて使い始めたばかりで上手く動作しない時はは特にこれが当てはまります。

 * 上手く動作しない所を見つけた時、個別にテストして切り分けを行なって下さい。ØMQは基本的なモジュールコードを作成できます。これはあなたの助けになるでしょう。

 * 必要に応じてコードを上手く抽象化して下さい。同じコードをコピー&ペーストばかりしていたら、エラー箇所も増えてゆきます。

### 正しくコンテキストを取得する
ØMQアプリケーションはいつもコンテキストを作成し、それを利用してソケットを作成します。
C言語では`zmq_ctx_new()`を呼び出します。
あなたはプロセス内に一つのコンテキストを作成してそれを利用します。
技術的に言うと、コンテキストは単一プロセス内で全てのソケットをまとめるコンテナであり、プロセス内で高速にスレッド間を接続するプロセス内ソケットとして振る舞います。
もし、1つの実行プロセスが2つのコンテキスト持つと、それはØMQインスタンスが2に分離しているように見えます。
あえてこうしたいのであれば問題ありませんが、そうでないのなら注意して下さい。

*メインコードの最初で`zmq_ctx_new()`呼び出して、終わりに`zmq_ctx_destroy()`を呼び出して下さい。*

`fork()`システムコールを利用している場合、各プロセスは独自のコンテキストを必要とします。
メインプロセスで`zmq_ctx_new()`を呼び出した後に`fork()`した場合、子プロセスは独自のコンテキストを得ます。一般的に、子プロセスで主な処理を行い親プロセスは子プロセスを管理するだけでしょう。

### 正しく終了する
一流のプログラマは一流の殺し屋と同じ教訓を共有します。「仕事が終わったら後片付けしろ」という事です。
ØMQをPythonの様な言語で利用している場合、オブジェクトは自動的に開放されます。
しかし、C言語の場合は慎重にオブジェクトを開放する必要があります。
そうしなければメモリリークが発生したり、アプリケーションが不安定になったり、罰が下ったりします。

メモリリークもその一つです。
ØMQはアプリケーションを終了することに関してとても気難しいです。
理由は、技術的かつ痛みを伴いますが、もしソケットをオープンしたまま`zmq_ctx_destroy()`関数を呼び出した場合、永久にハングします。
そしてもし、LINGERを0に設定せずに全てのソケットクローズした場合でも、`zmq_ctx_destroy()`で待たされるでしょう。

ØMQで気にする必要があるオブジェクトはメッセージとソケットとコンテキストの3つです。
幸いなことに、単純なプログラムでこれを扱うのは非常に簡単です。

 * できるだけ、`zmq_send()`と`zmq_recv()`を使って下さい。これらはzmq_msg_tオブジェクトの利用を避けることが出来ます。

 * `zmq_msg_recv()`を使う場合、メッセージを受信したら`zmq_msg_close()`を呼ぶ前に出来るだけ早く開放して下さい。

 * 多くのソケットをオープンしてクローズする場合、アプリケーションを再設計する必要性がある兆候です。幾つかのケースでは、コンテキストを開放するまでソケットが開放されなくなります。

 * プログラムを終了する際、ソケットを閉じてから`zmq_ctx_destroy()`を呼んで下さい。こうしないとコンテキストが壊れます。

最後のケースはC言語で開発する場合です。
多くの言語では、スコープが外れた時にソケットやコンテキストなどのオブジェクトは自動的に開放されます。
もし例外を利用する場合は"final"ブロックでこれらのリソースを開放すると良いでしょう。

マルチスレッドを利用している場合、これはもっと複雑になります。
マルチスレッドに関しては次の章で扱いますが、警告を無視しして試して見る人もいるでしょう。
以下は、マルチスレッドのØMQアプリケーションで正しく終了するための急しのぎのガイドです。

まず、複数のスレッドから同一のソケットを使わないで下さい。
冗談ではありません、やらないで下さい。
次に、リクエスト中のソケットを接続を切る時はLINGERに小さい値(1秒程度)を設定し、それから接続を閉じて下さい。
もしあなたの利用している言語バインディングがこれを行わない場合、修正してパッチを送ることを推奨します。

最後に、コンテキストを開放します。
これを行うと、コンテキストを共有して送受信を行なっている別のスレッドでエラーが返ります。
エラーを拾い、`LINGER`を設定してソケットをクローズして下さい。
同じコンテキストを２回開放しないで下さい。
`zmq_ctx_destroy()`は全てのソケットが安全に閉じられるまでメインスレッドでブロックします。

おしまい!これはとても複雑で痛みを伴いますが、有能な言語バインディングの作者が自動的にソケットを閉じてくれるので必ずしもこれを行う必要はないでしょう。

## なぜØMQが必要なのか
これまでØMQの動作について見てきましたが、前に戻って「何故」の話に戻りましょう。

今日多くのアプリケーションはLANやインターネットなどのネットワークを横断する機能を有しています。
そして多くのアプリケーション開発者は最終的メッセージング機能を必要とします。
開発者の中にはメッセージキュー製品を利用する人もいますが、ほとんどの人はTCPやUDPを利用して自前で実装します。
これらのプロトコルを利用するのは難しいことではありませんが、単にAからBへメッセージを送信する事と、信頼性のある方法でこれを行うのとでは大きな違いあがあります。

それでは生のTCPを利用して部品を接続する際に発生する典型的な問題を見て行きましょう。
際利用可能なメッセージングレイヤを実装するにはこれらの問題を解決する必要があります。

 * I/O処理をどの様に行うか。ブロッキングI/Oか非同期I/Oのどっちにする?これは重要な仕様判断です。ブロッキングI/Oを選択するとスケーラビリティの無いアーキテクチャになります。一方、非同期I/Oを正しく実装するのはとても難しいです。

 * 動的なコンポーネントをどの様に処理するか。例えば部品が一時的に停止した時どうしますか? 一般的にコンポーネントは「サーバー」と「クライアント」に別れていることが多いですが、サーバーが落ちてしまった時どうしますか? サーバーとサーバーが接続するような場合は? 数秒毎に再接続するようにしますか?

 * メッセージをネットワーク上でどの様に表現するか。どの様にしてデータフレームを簡単に読み書きしたり、バッファーオーバーフローが起きないようにしたり、小さいメッセージを効果的に転送したり、パーティ用帽子をかぶった猫が踊っている巨大な動画を見ますか?

 * 即座に配信できないメッセージをどの様に処理するか。例えばコンポーネントが一時的にオフラインである場合、メッセージを破棄しますか? データベースに入れておきますか? それともメモリーキューに入れておきますか?

 * メッセージキューを何処に格納するか。キューが増えてきて読み込みが遅くなった時はどうしますか? その時の戦略は?

 * 欠落したデータをどの様に処理するか。新しいデータを待ちますか? リクエストを再送しますか? 信頼性のあるレイヤでネットワークを構築すればメッセージは欠落しないって? そのレイヤ自体がクラッシュしたらどうするの?

 * 複数のネットワークに配送する場合はどうする? TCPユニキャストの代わりにマルチキャストとかIPv6を使う? アプリケーションを書きなおしますか? ネットワークレイヤを抽象化しますか?

 * どの様にメッセージをルーティングする? 同じメッセージを複数の相手に送れる? 元のリクエスト送信者に返信出来る?

 * どうやってAPIをいろんな言語で実装する? ネットワークレベルのプロトコルを再実装する? ライブラリを再実装する? 前者ならどうやって安定したスタックを保証しますか? 後者ならどうやって相互運用性を保証しますか?

 * 異なるアーキテクチャでどの様にデータを表現しますか? 特定のデータエンコーディングに統一しますか? 何処までがメッセージングシステムの仕事で何処からが上位アプリケーションレイヤの仕事でしょうか?

 * ネットワークエラーをどの様に処理しますか? リトライしますか? 静かに無視しますか? 処理を中断しますか?

2013年1月頃、典型的オープンソースプロジェクトであるHadoop ZookeeperのC APIコード(src/c/src/zookeeper.c)を読んでみると、4,200行のコードは謎めいていて、クライアント/サーバーの通信プロトコルはドキュメント化されていませんでした。
それはselectではなく効率的なpollを利用している事が確認できました。
Zookeeperはもっと一般的なメッセージングレイヤを利用し、ドキュメント化されたネットワークプロトコルを使ったほうが良いでしょうが、それはチームにとって車輪の再発明を繰り返す事になりとてつもなく無駄です。

しかしどうやって再利用可能なメッセージングレイヤを作るのでしょうか? 
多くのプロジェクトでこの技術が必要とされているにも関わらず、何故人々は未だにTCPソケットを直に触って先ほど挙げた問題を解決するために繰り返し苦労しているのでしょうか。

再利用可能なメッセージングシステムを作るのが本当に難しいということは、これを行うFOSSプロジェクトが少ないことや、商用メッセージング製品が複雑、高価で柔軟性が無く、不安定であることからも分ります。
2006年にiMatix社はAMQPという再利用可能なメッセージングシステムを恐らく最初にFOSS開発者に提供しました。
AMQPはその他の設計より上手く動作していましたが比較的複雑で高価で不安定でした。
数週間掛けて使い方を学び、数ヶ月掛けて安定したアーキテクチャを作り上げた結果、恐ろしいクラッシュが発生しなくなりました。

![Messaging as it Starts](images/fig7.eps)

多くのメッセージングプロジェクトと同様に、AMQPも先ほど挙げた問題をアドレッシング、ルーティング、キューングを行う「ブローカー」という新しい概念を用いて解決しようとしました。
その結果、アプリケーションはブローカーに対して、クライアント/サーバープロトコルや、APIを利用してドキュメント化されていないプロトコルをやり取りするようになりました。
ブローカーは巨大で複雑なネットワークを縮小させる事に役立ちましたが、ブローカーをベースとしたメッセージングはZookeeperの様な製品では必ずしも良い結果が得られませんでした。
高性能なサーバーを追加していく内に、ブローカーが単一故障点になってしまったのです。
あっという間にブローカーはボトルネックとなり、管理上のリスクとなりました。
これをソフトウェアで解決する場合、第2、第3、第4のブローカーを追加し、フェイルオーバーの仕組みを作る必要がありました。人々がこれを行った結果、より多くの部品が増え、複雑になり、いろいろなものが壊れました。

そして中央ブローカーのセットアップには、専用の運用チームが必要でした。
そして、ブローカーを昼夜構わず監視し、素行の悪いヤツを見つけて棒で叩く必要がありました。
新しいサーバーが必要になり、さらにそのバックアップサーバーが必要になり、そのサーバーを管理する人材が必要になります。この様な状況は、幾つものチームで数年に渡って運用する大規模なアプリケーションにおいては価値があります。

![Messaging as it Becomes](images/fig8.eps)

つまり、中小規模のアプリケーション開発者にとってこれは罠なのです。
ネットワークプログラミング避けて一枚岩なアプリケーションを作るか、
ネットワークプログラミングに挑戦して不安定で複雑なアプリケーションを作り、メンテナンスに苦しむか、
メッセージング製品に頼ってスケーラブルだけど、高価で壊れやすいアプリケーションとなるか、という選択肢があります。
何故、前世紀のメッセージングが巨大であったかを考えると、これらは本当に良い選択肢ではありません。
サポートやライセンス販売する人は大喜びでしょうが、ユーザーにとって良い事は一つもないからです。

私達に必要なのはシンプルかつ安価で様々なアプリケーションで動作するメッセージングを機能です。
それは何にも依存せずリンクできるライブラリでなければなりません。
追加の部品は必要ありません、すなわち追加のリスクはありません。
それは、あらゆるOSとあらゆるプログラミング言語で動作しなければなりません。

そうして出来たのがØMQです。
ØMQはアプリケーションがネットワークを縦横無尽にまたぐ為に必要な問題を解決する、低コストで効率的な組み込みライブラリです。

仕様:

 * I/Oはバックグラウンドのスレッドで非同期に処理します。アプリケーションスレッドはロックフリーなデータ構造を利用して通信を行うので、ØMQアプリケーションはロックやセマフォなどの同期処理を必要としません。

 * コンポーネントを動的にできるように、ØMQは自動的に再接続を行います。これにより、どの様な順番でコンポーネントを実行てもよくなります。そしていつでもネットワークに参加して離脱出来る、サービス指向アーキテクチャを作ることが出来ます。

 * メッセージは必要に応じてキューに入れられます。それは賢く、メッセージは受信者に出来るだけ近いキューに入れられます。

 * キューが溢れないように対応します。(high water markと呼ばれます)キューが一杯になった時、ØMQは自動的に送信側をブロックするか、あるいはメッセージ捨てるかどうかをメッセージの種類によってコントロールできます。(これを「パターン」と呼びます。)

 * アプリケーションは様々な通信手段を利用して、通信する事が出来ます。例えば、TCP, マルチキャスト、プロセス間通信、プロセス内通信など。異なる通信手段を利用するためにコードを修正する必要はありません。

 * 受信側の読み込みが遅かったりブロックされている場合でも、メッセージパターンによって異なる戦略を利用して安全に処理します。

 * リクエスト-応答パターンや、pub-subパターンなど、様々なパターンを利用してメッセージをルーティング出来ます。これらのパターンによりネットワーク構造のトポロジーを構成できます。

 * キューのプロクシを構成したり、メッセージを採取したり転送したり出来ます。プロクシは相互接続によるネットワークの複雑性を緩和します。

 * 配送されたメッセージはフレーム境界を維持してそのまま送信されます。10Kバイトのメッセージを書き込んだ場合、受信側では10Kバイトのメッセージを受け取ります。

 * メッセージのフォーマットについては関わりません。データサイズはゼロかもしれませんし、何ギガバイトもの巨大サイズかもしれません。データの表現方法についてはmsgpackやGoogleのprotocol buffersなどの好きなライブラリを選んで使って下さい。

 * ネットワークエラーを賢く処理します。それが理にかなっている時は再試行を行います。

 * 二酸化炭素排出量を削減します。サーバーのCPU利用量と利用電力を減らします。そして古いサーバーを長く使い続けることが出来ます。アル・ゴアはØMQを気に入るでしょう。

実際のところØMQはこれらの事よりもっと多くのことを行います。
それはネットワーク機能を持ったアプリケーションの開発に多大な影響を及ぼします。
一見、zmq_recv()やzmq_send()はソケットAPIと同じように見えますが、メッセージ処理タスクは即座に中央ループに入り、複数のタスクに分解されます。
これは上品で自然な動作です。
そしてこれらのタスクはノードに対応付けされ、任意の通信経路を経由してノードに転送されます。
1プロセスに2ノード配置する時、ノードとはスレッドを意味します。
1つのサーバーに2ノード配置する時、ノードはプロセスの事です。
1つのネットワークに2ノード配置する場合、ノードはサーバーを意味します。
これらは全て同じように、アプリケーションを変更せず構成する事ができます。

## ソケットスケーラビリティ
ØMQのスケーラビリティを見てみましょう。
これは天気配信サーバーを起動し、クライアントを並列に実行するシェルスクリプトです。

~~~
wuserver &
wuclient 12345 &
wuclient 23456 &
wuclient 34567 &
wuclient 45678 &
wuclient 56789 &
~~~

4コアのマシンでクライアントの実行中に、topコマンドを利用すると以下のようなプロセス情報を確認できます。

~~~
PID  USER  PR  NI  VIRT  RES  SHR S %CPU %MEM   TIME+  COMMAND
7136  ph   20   0 1040m 959m 1156 R  157 12.0 16:25.47 wuserver
7966  ph   20   0 98608 1804 1372 S   33  0.0  0:03.94 wuclient
7963  ph   20   0 33116 1748 1372 S   14  0.0  0:00.76 wuclient
7965  ph   20   0 33116 1784 1372 S    6  0.0  0:00.47 wuclient
7964  ph   20   0 33116 1788 1372 S    5  0.0  0:00.25 wuclient
7967  ph   20   0 33072 1740 1372 S    5  0.0  0:00.35 wuclient
~~~

ここで何が起こっているのか少し考えてみましょう。
天気情報サーバーは1つのソケットを持ち、5つのクライアントにデータを並行に送信しています。
私達は並行クライアントを数千ほどに増やすことが出来ます。
サーバーアプリケーションにこれらのコードは直接記述されていません。
静かにクライアントのリクエストを受け付け、出来るだけ素早くネットワークにデータを配信する小さなサーバとして機能振る舞っています。
そして、それはマルチスレッドサーバーであり、CPUリソースを無駄なく絞りとれています。

## ØMQ v2.2 から ØMQ v3.2 へのアップグレード
### 互換性のある変更
これらの変更は既存のアプリケーションコードに直接影響はありません。

 * Pub-subフィルタリングをサブスクライバ側だけでなくパブリッシャーサイドでも行えるようになった。これは多くのpub-subユースケースでパフォーマンスを大きく改善します。v3.2とv2.1/v2.2を組み合わせても安全です。

 * ØMQ v3.2 で多くの新しいAPIが追加されました。(`zmq_disconnect()`, `zmq_unbind()`, `zmq_monitor()`, `zmq_ctx_set()`, など)

### 互換性の無い変更
アプリケーションや言語バインディングが影響を受ける主な変更です。

 * `zmq_send()`と`zmq_recv()`メソッドのインターフェースが変更されました。古い関数は現在`zmq_msg_send()`と`zmq_msg_recv()`という名前で提供されています。症状: コンパイルエラーが発生します。解決方法: コードを修正する必要があります。

 * これらの2つのメソッドは、成功すると正の値、エラーが発生すると-1を返します。バージョン2では成功時は常に0を返していました。症状: 正常な動作なのにエラーが発生したように見えてしまう。解決方法: エラー処理を厳密に -1 と非ゼロで判定すること。

 * `zmq_poll()`はミリ秒ではなく、マイクロ秒待つようになりました。症状: アプリケーションの応答が止まって見える(正確には1000倍遅くなる)。解決方法: `zmq_poll()`を呼び出す時に、新しく定義された`ZMQ_POLL_MSEC`マクロを利用して下さい。

 * `ZMQ_NOBLOCK`マクロは`ZMQ_DONTWAIT`という名前に変更になりました。症状: コンパイルエラー

 * ZMQ_HWMソケットオプションは、ZMQ_SNDHWMとZMQ_RCVHWMに分割されました。症状: コンパイルエラー

 * 全てではありませんが、ほとんどの`zmq_getsockopt()`オプションの値は整数値です。症状: `zmq_setsockopt()`や`zmq_getsockopt()`の実行時にエラーが発生します。

 * `ZMQ_SWAP`オプションは削除されました。症状: コンパイルエラー。解決方法: この機能を利用したコードを再設計して下さい。

### 調整マクロの推奨
アプリケーションをv2.xとv3.2の両方で動作させたい場合があります。
以下のCマクロ定義は、両方のバージョンで動作させる為に役立ちます。

~~~
#ifndef ZMQ_DONTWAIT
# define ZMQ_DONTWAIT ZMQ_NOBLOCK
#endif
#if ZMQ_VERSION_MAJOR == 2
#   define zmq_msg_send(msg,sock,opt) zmq_send (sock, msg, opt)
#   define zmq_msg_recv(msg,sock,opt) zmq_recv (sock, msg, opt)
#   define zmq_ctx_destroy(context) zmq_term(context)
#   define ZMQ_POLL_MSEC 1000 // zmq_poll is usec
#   define ZMQ_SNDHWM ZMQ_HWM
#   define ZMQ_RCVHWM ZMQ_HWM
#elif ZMQ_VERSION_MAJOR == 3
#   define ZMQ_POLL_MSEC 1 // zmq_poll is msec
#endif
~~~

## 警告: 不安定なパラダイム!
従来のネットワークプログラミングは一般的に1ソケットに対して1つの接続、1ピアと会話することを前提にして構築されています。
マルチキャストプロトコルがありますが、しかしこれらはエキゾチックです。
私達は「1ソケット = 1コネクション」を前提としたアーキテクチャを有る意味で拡張しました。
論理的なスレッドを作成しそれぞれのスレッドが1ソケット, 1ピアとして機能します。
これらのスレッドに情報や状態を格納します。

ØMQの世界では、全てのコネクションの集合を自動的に管理する早くて小さい通信エンジンへの出入口です。
あなたはオープンやクローズ、コネクションに設定された状態の設定を見ることが出来ません。
送受信をブロッキングで行うかポーリングするかどうかはあなたがソケットと会話して決定します。コネクションはこれを自動的に管理しません。
コネクションは隠蔽化しているため直接見えませんが、これがØMQのスケーラビリティの重要な鍵になります。

なぜならソケットと会話することで、ネットワークプロトコルやコネクション数を操作することが出来るからです。
ØMQにおいては、メッセージングパターンはより手軽に拡張出来るようになります。

ですので一般的な仮定は通用しなくなりました。
サンプルコードを読む時に、あなたの頭の中で、既存の知識とマッピングしようとするかもしれません。
「ソケット」という言葉を見た時、「ああ、これは別のノードへのコネクションを表すのね」と思うでしょうが誤りです。
「スレッド」という言葉を見た時、「ああ、スレッドが別ノードへのコネクションを制御しているのね」と思うかもしれませんが、これもまた誤りです。

このガイドブックを初めて読んでいるのなら、実際にØMQのコードを書けるようになるまで1,2日(もしくは3,4日)かかるでしょう。
特に、ØMQがどの様に物事を単純化しているかについてあなたは混乱するかもしれません。あるいはØMQで一般的な仮定を適用しようとして上手く行かないかもしれません。
そして全てが明らかになったその時、あなたはzap-pow-kaboomパラダイムシフトの真理と悟りの瞬間を経験するでしょう。

